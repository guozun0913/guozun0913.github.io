---
layout: post
title:  "Deepsortç®—æ³•ç¬”è®°"
date:   2024-4-26 22:03:30 +0800--
categories: [ç®—æ³•]
tags: [Deepsort]  
---

### Deepsortç®—æ³•ç¬”è®°1

![](https://img2.imgtp.com/2024/04/23/XKTdi6O2.jpg)

##### 1.1ä»€ä¹ˆæ˜¯Deepsort

â€‹		DeepSORTæ˜¯ä¸€ç§ç›®æ ‡è·Ÿè¸ªç®—æ³•ï¼Œå®ƒç»“åˆäº†æ·±åº¦å­¦ä¹ å’Œå¡å°”æ›¼æ»¤æ³¢çš„æŠ€æœ¯ã€‚å®ƒæœ€åˆæ˜¯ç”¨äºå¤šç›®æ ‡è·Ÿè¸ªçš„æ·±åº¦å­¦ä¹ ç‰ˆæœ¬ã€‚é€šè¿‡ç»“åˆå·ç§¯ç¥ç»ç½‘ç»œï¼ˆCNNï¼‰å’Œå¡å°”æ›¼æ»¤æ³¢ï¼ŒDeepSORTå¯ä»¥å®ç°åœ¨è§†é¢‘ä¸­å‡†ç¡®è·Ÿè¸ªå¤šä¸ªå¯¹è±¡ï¼Œå¹¶ä¸”èƒ½å¤Ÿåœ¨å¯¹è±¡å‡ºç°é®æŒ¡æˆ–è€…ä¸¢å¤±çš„æƒ…å†µä¸‹ç»§ç»­è·Ÿè¸ªã€‚DeepSORTæ˜¯SORTï¼ˆSimple Online and Realtime Trackingï¼‰ç®—æ³•çš„æ‰©å±•ï¼Œå®ƒå°†æ·±åº¦å­¦ä¹ DæŠ€æœ¯å¼•å…¥äº†ä¼ ç»Ÿçš„å¤šç›®æ ‡è·Ÿè¸ªæ¡†æ¶ä¸­ï¼Œä»¥æé«˜å‡†ç¡®æ€§å’Œç¨³å®šæ€§ã€‚

##### 1.2 å¡å°”æ›¼æ»¤æ³¢

â€‹		å¡å°”æ›¼æ»¤æ³¢ï¼ˆKalman Filterï¼‰æ˜¯ä¸€ç§ç”¨äºä¼°è®¡ç³»ç»ŸçŠ¶æ€çš„æ•°å­¦ç®—æ³•ï¼Œå®ƒé€šè¿‡å°†ç³»ç»Ÿçš„æµ‹é‡å€¼å’Œæ¨¡å‹çš„é¢„æµ‹å€¼è¿›è¡ŒåŠ æƒå¹³å‡ï¼Œæ¥ä¼˜åŒ–å¯¹ç³»ç»Ÿå½“å‰çŠ¶æ€çš„ä¼°è®¡ã€‚è¯¥ç®—æ³•æœ€åˆç”±Rudolf E. KÃ¡lmÃ¡næå‡ºï¼Œç”¨äºèˆªç©ºå’Œèˆªå¤©é¢†åŸŸçš„å¯¼èˆªç³»ç»Ÿä¸­ã€‚

â€‹			ä½ å¯ä»¥åœ¨ä»»ä½•å«æœ‰ä¸ç¡®å®šå› ç´ çš„åŠ¨æ€ç³»ç»Ÿé‡Œä½¿ç”¨å¡å°”æ›¼æ»¤æ³¢ï¼Œè€Œä¸”ä½ åº”è¯¥å¯ä»¥é€šè¿‡æŸç§æ•°å­¦å»ºæ¨¡å¯¹ç³»ç»Ÿä¸‹ä¸€æ­¥åŠ¨å‘åšä¸€ä¸ªå¤§æ¦‚çš„é¢„æµ‹ã€‚å°½ç®¡ç³»ç»Ÿæ€»æ˜¯ä¼šå—åˆ°ä¸€äº›æœªçŸ¥çš„å¹²æ‰°ï¼Œä½†æ˜¯å¡å°”æ›¼æ»¤æ³¢æ€»æ˜¯å¯ä»¥æ´¾ä¸Šç”¨åœºæ¥æé«˜ç³»ç»Ÿé¢„ä¼°çš„ç²¾ç¡®åº¦ï¼Œè¿™æ ·ä½ å°±å¯ä»¥æ›´åŠ å‡†ç¡®åœ°çŸ¥é“åˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆäº‹æƒ…(ç³»ç»ŸçŠ¶æ€æ˜¯å¦‚ä½•è½¬ç§»çš„)ã€‚è€Œä¸”å®ƒå¯ä»¥æœ‰æ•ˆåˆ©ç”¨å¤šä¸ªç²—ç³™æ•°æ®ä¹‹é—´çš„å…³ç³»ï¼Œè€Œå•ç‹¬é¢å¯¹è¿™äº›æ•°æ®ä½ å¯èƒ½éƒ½æ— ä»ä¸‹æ‰‹ã€‚

â€‹	å¡å°”æ›¼æ»¤æ³¢å°¤å…¶é€‚åˆåŠ¨æ€ç³»ç»Ÿã€‚å®ƒå¯¹äºå†…å­˜è¦æ±‚æä½ï¼ˆå®ƒä»…éœ€è¦ä¿ç•™ç³»ç»Ÿä¸Šä¸€ä¸ªçŠ¶æ€çš„æ•°æ®ï¼Œè€Œä¸æ˜¯ä¸€æ®µè·¨åº¦å¾ˆé•¿çš„å†å²æ•°æ®ï¼‰ã€‚å¹¶ä¸”å®ƒè¿ç®—å¾ˆå¿«ï¼Œè¿™ä½¿å¾—å®ƒéå¸¸é€‚åˆè§£å†³å®æ—¶é—®é¢˜å’Œåº”ç”¨äºåµŒå…¥å¼ç³»ç»Ÿã€‚

##### 1.3 å¡å°”æ›¼æ»¤æ³¢çš„åŸç†

â€‹			å‡è®¾ç°æœ‰ä¸€è¾†å°è½¦ï¼Œå®ƒå¯ä»¥åœ¨åœ°å›¾ä¸Šè‡ªä¸»ç§»åŠ¨ï¼Œå¹¶ä¸”è¿™æ¬¾å°è½¦éœ€è¦æ˜ç¡®è‡ªå·±çš„ä½ç½®ä»¥ä¾¿è¿›è¡Œå¯¼èˆªã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ç»„çŠ¶æ€å˜é‡ ğ‘¥Â¯ æ¥æè¿°å°è½¦çš„çŠ¶æ€ï¼ŒåŒ…æ‹¬ä½ç½®å’Œé€Ÿåº¦ï¼š

â€‹			                                		<img src="https://img2.imgtp.com/2024/04/23/MAS0z612.png" style="zoom:150%;" />

â€‹	

â€‹		æ³¨æ„è¿™ä¸ªçŠ¶æ€ä»…ä»…æ˜¯ç³»ç»Ÿæ‰€æœ‰çŠ¶æ€ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œä½ å¯ä»¥é€‰å–ä»»ä½•æ•°æ®å˜é‡ä½œä¸ºè§‚æµ‹çš„çŠ¶æ€ã€‚åœ¨æˆ‘ä»¬è¿™ä¸ªä¾‹å­ä¸­é€‰å–çš„æ˜¯ä½ç½®å’Œé€Ÿåº¦ï¼Œå®ƒä¹Ÿå¯ä»¥æ˜¯æ°´ç®±ä¸­çš„æ°´ä½ï¼Œæ±½è½¦å¼•æ“çš„æ¸©åº¦ï¼Œä¸€ä¸ªç”¨æˆ·çš„æ‰‹æŒ‡åœ¨å¹³æ¿ä¸Šåˆ’è¿‡çš„ä½ç½®ï¼Œæˆ–è€…ä»»ä½•ä½ æƒ³è¦è·Ÿè¸ªçš„æ•°æ®ã€‚

â€‹		æˆ‘ä»¬çš„å°è½¦åŒæ—¶æ‹¥æœ‰ä¸€ä¸ªGPSä¼ æ„Ÿå™¨ï¼Œç²¾åº¦åœ¨10mã€‚è¿™å·²ç»å¾ˆå¥½äº†ï¼Œä½†æ˜¯å¯¹æˆ‘ä»¬çš„å°è½¦æ¥è¯´å®ƒéœ€è¦ä»¥è¿œé«˜äº10mçš„è¿™ä¸ªç²¾åº¦æ¥å®šä½è‡ªå·±çš„ä½ç½®ã€‚åœ¨å°è½¦æ‰€å¤„çš„åœ°å›¾é‡Œæœ‰å¾ˆå¤šæºªè°·å’Œæ–­å´–ï¼Œå¦‚æœå°è½¦å¯¹ä½ç½®è¯¯åˆ¤äº†å“ªæ€•åªæ˜¯å‡ æ­¥è¿œçš„è·ç¦»ï¼Œå®ƒå°±æœ‰å¯èƒ½æ‰åˆ°å‘é‡Œã€‚æ‰€ä»¥ä»…é GPSæ˜¯ä¸å¤Ÿçš„ã€‚

â€‹		åŒæ—¶æˆ‘ä»¬å¯ä»¥è·å–åˆ°ä¸€äº›å°è½¦çš„è¿åŠ¨çš„ä¿¡æ¯ï¼šé©±åŠ¨è½®å­çš„ç”µæœºæŒ‡ä»¤å¯¹æˆ‘ä»¬ä¹Ÿæœ‰ç”¨å¤„ã€‚å¦‚æœæ²¡æœ‰å¤–ç•Œå¹²æ‰°ï¼Œä»…ä»…æ˜¯æœä¸€ä¸ªæ–¹å‘å‰è¿›ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªæ—¶åˆ»çš„ä½ç½®åªæ˜¯æ¯”ä¸Šä¸€ä¸ªæ—¶åˆ»çš„ä½ç½®åœ¨è¯¥æ–¹å‘ä¸Šç§»åŠ¨äº†ä¸€ä¸ªå›ºå®šè·ç¦»ã€‚å½“ç„¶æˆ‘ä»¬æ— æ³•è·å–å½±å“è¿åŠ¨çš„æ‰€æœ‰ä¿¡æ¯ï¼šå°è½¦å¯èƒ½ä¼šå—åˆ°é£åŠ›å½±å“ï¼Œè½®å­å¯èƒ½ä¼šæ‰“æ»‘ï¼Œæˆ–è€…ç¢°åˆ°äº†ä¸€äº›ç‰¹æ®Šçš„è·¯å†µï¼›æ‰€ä»¥è½®å­è½¬è¿‡çš„è·ç¦»å¹¶ä¸èƒ½å®Œå…¨è¡¨ç¤ºå°è½¦ç§»åŠ¨çš„è·ç¦»ï¼Œè¿™å°±å¯¼è‡´é€šè¿‡è½®å­è½¬åŠ¨é¢„æµ‹å°è½¦ä½ç½®ä¸ä¼šéå¸¸å‡†ç¡®ã€‚

â€‹	GPSä¼ æ„Ÿå™¨ä¹Ÿä¼šå‘ŠçŸ¥æˆ‘ä»¬ä¸€äº›å…³äºå°è½¦çŠ¶æ€çš„ä¿¡æ¯ï¼Œä½†æ˜¯ä¼šåŒ…å«ä¸€äº›ä¸ç¡®å®šæ€§å› ç´ ã€‚æˆ‘ä»¬é€šè¿‡è½®å­è½¬åŠ¨å¯ä»¥é¢„çŸ¥å°è½¦æ˜¯å¦‚ä½•è¿åŠ¨çš„ï¼ŒåŒæ ·ä¹Ÿæœ‰ä¸€å®šçš„ä¸å‡†ç¡®åº¦ã€‚

â€‹	å¦‚æœæˆ‘ä»¬ç»¼åˆä¸¤è€…çš„ä¿¡æ¯å‘¢ï¼Ÿå¯ä»¥å¾—åˆ°æ¯”åªä¾é å•ç‹¬ä¸€ä¸ªä¿¡æ¯æ¥æºæ›´ç²¾ç¡®çš„ç»“æœä¹ˆï¼Ÿç­”æ¡ˆå½“ç„¶æ˜¯YESï¼Œè¿™å°±æ˜¯å¡å°”æ›¼æ»¤æ³¢è¦è§£å†³çš„é—®é¢˜ã€‚

â€‹												åŒæ ·æ˜¯ä¸Šè¾¹çš„ç³»ç»Ÿï¼Œç³»ç»ŸçŠ¶æ€åŒ…æ‹¬ä½ç½®å’Œé€Ÿåº¦ã€‚

![](https://img2.imgtp.com/2024/04/23/RvmNWcs7.png)

æˆ‘ä»¬ä¸çŸ¥é“ä½ç½®å’Œé€Ÿåº¦çš„å‡†ç¡®å€¼ï¼›ä½†æ˜¯æˆ‘ä»¬å¯ä»¥åˆ—å‡ºä¸€ä¸ªå‡†ç¡®æ•°å€¼å¯èƒ½è½åœ¨çš„åŒºé—´ã€‚åœ¨è¿™ä¸ªèŒƒå›´é‡Œï¼Œä¸€äº›æ•°å€¼ç»„åˆçš„å¯èƒ½æ€§è¦é«˜äºå¦ä¸€äº›ç»„åˆçš„å¯èƒ½æ€§

![](https://img2.imgtp.com/2024/04/23/ylEDM2l7.png)



##### 1.4å¡å°”æ›¼æ»¤æ³¢çš„è®¡ç®—

ä»¬è¦è·Ÿè¸ªå°è½¦çš„ä½ç½®å˜åŒ–ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œè“è‰²çš„åˆ†å¸ƒæ˜¯å¡å°”æ›¼æ»¤æ³¢é¢„æµ‹å€¼ï¼Œæ£•è‰²çš„åˆ†å¸ƒæ˜¯ä¼ æ„Ÿå™¨çš„æµ‹é‡å€¼ï¼Œç°è‰²çš„åˆ†å¸ƒå°±æ˜¯é¢„æµ‹å€¼åŸºäºæµ‹é‡å€¼æ›´æ–°åçš„æœ€ä¼˜ä¼°è®¡ã€‚

![](https://img2.imgtp.com/2024/04/23/JDiuIW8m.jpg)

åœ¨ç›®æ ‡è·Ÿè¸ªä¸­ï¼Œéœ€è¦ä¼°è®¡trackçš„ä»¥ä¸‹ä¸¤ä¸ªçŠ¶æ€ï¼š

|                     |                                                              |
| ------------------- | ------------------------------------------------------------ |
| å‡å€¼(Mean)          | è¡¨ç¤ºç›®æ ‡çš„ä½ç½®ä¿¡æ¯ï¼Œç”±bboxçš„ä¸­å¿ƒåæ ‡ (cx, cy)ï¼Œå®½é«˜æ¯”rï¼Œé«˜hï¼Œä»¥åŠå„è‡ªçš„é€Ÿåº¦å˜åŒ–å€¼ç»„æˆï¼Œç”±8ç»´å‘é‡è¡¨ç¤ºä¸º x = [cx, cy, r, h, vx, vy, vr, vh]ï¼Œå„ä¸ªé€Ÿåº¦å€¼åˆå§‹åŒ–ä¸º0ã€‚ |
| åæ–¹å·®(Covariance ) | è¡¨ç¤ºç›®æ ‡ä½ç½®ä¿¡æ¯çš„ä¸ç¡®å®šæ€§ï¼Œç”±8x8çš„å¯¹è§’çŸ©é˜µè¡¨ç¤ºï¼ŒçŸ©é˜µä¸­æ•°å­—è¶Šå¤§åˆ™è¡¨æ˜ä¸ç¡®å®šæ€§è¶Šå¤§ï¼Œå¯ä»¥ä»¥ä»»æ„å€¼åˆå§‹åŒ–ã€‚ |
|                     |                                                              |





å¡å°”æ›¼æ»¤æ³¢åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼š(1) é¢„æµ‹trackåœ¨ä¸‹ä¸€æ—¶åˆ»çš„ä½ç½®ï¼Œ(2) åŸºäºdetectionæ¥æ›´æ–°é¢„æµ‹çš„ä½ç½®ã€‚

ä¸‹é¢å°†ä»‹ç»è¿™ä¸¤ä¸ªé˜¶æ®µç”¨åˆ°çš„è®¡ç®—å…¬å¼ã€‚ï¼ˆè¿™é‡Œä¸æ¶‰åŠå…¬å¼çš„åŸç†æ¨å¯¼ï¼Œå› ä¸ºæˆ‘ä¹Ÿä¸æ¸…æ¥šåŸç†(à²¥_à²¥) ï¼Œåªæ˜¯è¯´æ˜ä¸€ä¸‹å„ä¸ªå…¬å¼çš„ä½œç”¨ï¼‰

â€‹			åŸºäºtrackåœ¨**t-1**æ—¶åˆ»çš„çŠ¶æ€æ¥é¢„æµ‹å…¶åœ¨**t**æ—¶åˆ»çš„çŠ¶æ€ã€‚

![](https://img2.imgtp.com/2024/04/26/EoytsDmK.png)

åœ¨å…¬å¼1ä¸­ï¼Œxä¸ºtrackåœ¨t-1æ—¶åˆ»çš„å‡å€¼ï¼ŒFç§°ä¸ºçŠ¶æ€è½¬ç§»çŸ©é˜µï¼Œè¯¥å…¬å¼é¢„æµ‹tæ—¶åˆ»çš„x'ï¼š

![](https://img2.imgtp.com/2024/04/26/cZ5mzADY.jpg)

çŸ©é˜µFä¸­çš„dtæ˜¯å½“å‰å¸§å’Œå‰ä¸€å¸§ä¹‹é—´çš„å·®ï¼Œå°†ç­‰å·å³è¾¹çš„çŸ©é˜µä¹˜æ³•å±•å¼€ï¼Œå¯ä»¥å¾—åˆ°cx'=cx+dt\*vxï¼Œcy'=cy+dt\*vy...ï¼Œæ‰€ä»¥è¿™é‡Œçš„å¡å°”æ›¼æ»¤æ³¢æ˜¯ä¸€ä¸ªåŒ€é€Ÿæ¨¡å‹ï¼ˆConstant Velocity Modelï¼‰ã€‚

åœ¨å…¬å¼2ä¸­ï¼ŒPä¸ºtrackåœ¨t-1æ—¶åˆ»çš„åæ–¹å·®ï¼ŒQä¸ºç³»ç»Ÿçš„å™ªå£°çŸ©é˜µï¼Œä»£è¡¨æ•´ä¸ªç³»ç»Ÿçš„å¯é ç¨‹åº¦ï¼Œä¸€èˆ¬åˆå§‹åŒ–ä¸ºå¾ˆå°çš„å€¼ï¼Œè¯¥å…¬å¼é¢„æµ‹tæ—¶åˆ»çš„P'ã€‚

æºç è§£è¯»ï¼š

```python
#  kalman_filter.py
def predict(self, mean, covariance):

    std_pos = [
        self._std_weight_position * mean[3],
        self._std_weight_position * mean[3],
        1e-2,
        self._std_weight_position * mean[3]]
    std_vel = [
        self._std_weight_velocity * mean[3],
        self._std_weight_velocity * mean[3],
        1e-5,
        self._std_weight_velocity * mean[3]]
    
    motion_cov = np.diag(np.square(np.r_[std_pos, std_vel]))  # åˆå§‹åŒ–å™ªå£°çŸ©é˜µQ
    mean = np.dot(self._motion_mat, mean)  # x' = Fx
    covariance = np.linalg.multi_dot((self._motion_mat, covariance, self._motion_mat.T)) + motion_cov  # P' = FPF(T) + Q
 
    return mean, covariance
```



##### 1.5 æ›´ç²¾å‡†çš„å¡å°”æ›¼æ»¤æ³¢è®¡ç®—

åŸºäº**t**æ—¶åˆ»æ£€æµ‹åˆ°çš„detectionï¼Œæ ¡æ­£ä¸å…¶å…³è”çš„trackçš„çŠ¶æ€ï¼Œå¾—åˆ°ä¸€ä¸ªæ›´ç²¾ç¡®çš„ç»“æœã€‚

![](https://img2.imgtp.com/2024/04/26/VQSGKoP7.png)

åœ¨å…¬å¼3ä¸­ï¼Œ**z**ä¸ºdetectionçš„å‡å€¼å‘é‡ï¼Œä¸åŒ…å«é€Ÿåº¦å˜åŒ–å€¼ï¼Œå³**z=[cx, cy, r, h]**ï¼Œ**H**ç§°ä¸º**æµ‹é‡çŸ©é˜µ**ï¼Œå®ƒå°†trackçš„å‡å€¼å‘é‡x'æ˜ å°„åˆ°æ£€æµ‹ç©ºé—´ï¼Œè¯¥å…¬å¼è®¡ç®—detectionå’Œtrackçš„å‡å€¼è¯¯å·®ï¼›

åœ¨å…¬å¼4ä¸­ï¼Œ**R**ä¸ºæ£€æµ‹å™¨çš„**å™ªå£°çŸ©é˜µ**ï¼Œå®ƒæ˜¯ä¸€ä¸ª4x4çš„å¯¹è§’çŸ©é˜µï¼Œå¯¹è§’çº¿ä¸Šçš„å€¼åˆ†åˆ«ä¸ºä¸­å¿ƒç‚¹ä¸¤ä¸ªåæ ‡ä»¥åŠå®½é«˜çš„å™ªå£°ï¼Œä»¥ä»»æ„å€¼åˆå§‹åŒ–ï¼Œä¸€èˆ¬è®¾ç½®å®½é«˜çš„å™ªå£°å¤§äºä¸­å¿ƒç‚¹çš„å™ªå£°ï¼Œè¯¥å…¬å¼å…ˆå°†åæ–¹å·®çŸ©é˜µP'æ˜ å°„åˆ°æ£€æµ‹ç©ºé—´ï¼Œç„¶åå†åŠ ä¸Šå™ªå£°çŸ©é˜µRï¼›

å…¬å¼5è®¡ç®—**å¡å°”æ›¼å¢ç›ŠKï¼Œ**å¡å°”æ›¼å¢ç›Šç”¨äºä¼°è®¡è¯¯å·®çš„é‡è¦ç¨‹åº¦ï¼›

å…¬å¼6å’Œå…¬å¼7å¾—åˆ°æ›´æ–°åçš„å‡å€¼å‘é‡**x**å’Œåæ–¹å·®çŸ©é˜µ**Pã€‚**

æºç è§£è¯»ï¼š

```python
#  kalman_filter.py
def project(self, mean, covariance):
    """Project state distribution to measurement space.
        
    Parameters
    ----------
    mean: ndarray, the state's mean vector (8 dimensional array).
    covariance: ndarray, the state's covariance matrix (8x8 dimensional).

    Returns
    -------
    (ndarray, ndarray), the projected mean and covariance matrix of the given state estimate.
    """
    std = [self._std_weight_position * mean[3],
           self._std_weight_position * mean[3],
           1e-1,
           self._std_weight_position * mean[3]]
        
    innovation_cov = np.diag(np.square(std))  # åˆå§‹åŒ–å™ªå£°çŸ©é˜µR
    mean = np.dot(self._update_mat, mean)  # å°†å‡å€¼å‘é‡æ˜ å°„åˆ°æ£€æµ‹ç©ºé—´ï¼Œå³Hx'
    covariance = np.linalg.multi_dot((
        self._update_mat, covariance, self._update_mat.T))  # å°†åæ–¹å·®çŸ©é˜µæ˜ å°„åˆ°æ£€æµ‹ç©ºé—´ï¼Œå³HP'H^T
    return mean, covariance + innovation_cov


def update(self, mean, covariance, measurement):
    """Run Kalman filter correction step.

    Parameters
    ----------
    mean: ndarra, the predicted state's mean vector (8 dimensional).
    covariance: ndarray, the state's covariance matrix (8x8 dimensional).
    measurement: ndarray, the 4 dimensional measurement vector (x, y, a, h), where (x, y) is the 
                 center position, a the aspect ratio, and h the height of the bounding box.
    Returns
    -------
    (ndarray, ndarray), the measurement-corrected state distribution.
    """
    # å°†meanå’Œcovarianceæ˜ å°„åˆ°æ£€æµ‹ç©ºé—´ï¼Œå¾—åˆ°Hx'å’ŒS
    projected_mean, projected_cov = self.project(mean, covariance)
    # çŸ©é˜µåˆ†è§£ï¼ˆè¿™ä¸€æ­¥æ²¡çœ‹æ‡‚ï¼‰
    chol_factor, lower = scipy.linalg.cho_factor(projected_cov, lower=True, check_finite=False)
    # è®¡ç®—å¡å°”æ›¼å¢ç›ŠKï¼ˆè¿™ä¸€æ­¥æ²¡çœ‹æ˜ç™½æ˜¯å¦‚ä½•å¯¹åº”ä¸Šå…¬å¼5çš„ï¼Œæ±‚çº¿ä»£å¤§ä½¬æŒ‡æ•™ï¼‰
    kalman_gain = scipy.linalg.cho_solve(
            (chol_factor, lower), np.dot(covariance, self._update_mat.T).T,
            check_finite=False).T
    # z - Hx'
    innovation = measurement - projected_mean
    # x = x' + Ky
    new_mean = mean + np.dot(innovation, kalman_gain.T)
    # P = (I - KH)P'
    new_covariance = covariance - np.linalg.multi_dot((kalman_gain, projected_cov, kalman_gain.T))
        
    return new_mean, new_covariance
```

 

##### 1.6åŒˆç‰™åˆ©ç®—æ³• 

é¦–å…ˆï¼Œå‡è®¾æœ‰Nä¸ªäººå’ŒNä¸ªä»»åŠ¡ï¼Œæ¯ä¸ªä»»åŠ¡å¯ä»¥ä»»æ„åˆ†é…ç»™ä¸åŒçš„äººï¼Œå·²çŸ¥æ¯ä¸ªäººå®Œæˆæ¯ä¸ªä»»åŠ¡è¦èŠ±è´¹çš„ä»£ä»·ä¸å°½ç›¸åŒï¼Œé‚£ä¹ˆå¦‚ä½•åˆ†é…å¯ä»¥ä½¿å¾—æ€»çš„ä»£ä»·æœ€å°ã€‚ **ï¼ˆåŠ¨æ€è§„åˆ’èƒŒåŒ…ç®—æ³•?ï¼‰**

â€‹	ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾ç°åœ¨æœ‰3ä¸ªä»»åŠ¡ï¼Œè¦åˆ†åˆ«åˆ†é…ç»™3ä¸ªäººï¼Œæ¯ä¸ªäººå®Œæˆå„ä¸ªä»»åŠ¡æ‰€éœ€**ä»£ä»·çŸ©é˜µï¼ˆcost matrixï¼‰**å¦‚ä¸‹æ‰€ç¤ºï¼ˆè¿™ä¸ªä»£ä»·å¯ä»¥æ˜¯é‡‘é’±ã€æ—¶é—´ç­‰ç­‰ï¼‰ï¼š

|          | task1 | task2 | task3 |
| -------- | ----- | ----- | ----- |
| person1  | 15    | 40    | 45    |
| persong2 | 20    | 60    | 35    |
| persong3 | 20    | 40    | 25    |

æ€æ ·æ‰èƒ½æ‰¾åˆ°ä¸€ä¸ªæœ€ä¼˜åˆ†é…ï¼Œä½¿å¾—å®Œæˆæ‰€æœ‰ä»»åŠ¡èŠ±è´¹çš„ä»£ä»·æœ€å°å‘¢ï¼Ÿ

åŒˆç‰™åˆ©ç®—æ³•ï¼ˆåˆå«KMç®—æ³•ï¼‰å°±æ˜¯ç”¨æ¥è§£å†³åˆ†é…é—®é¢˜çš„ä¸€ç§æ–¹æ³•ï¼Œå®ƒåŸºäºå®šç†

å¦‚æœä»£ä»·çŸ©é˜µçš„æŸä¸€è¡Œæˆ–æŸä¸€åˆ—åŒæ—¶åŠ ä¸Šæˆ–å‡å»æŸä¸ªæ•°ï¼Œåˆ™è¿™ä¸ªæ–°çš„ä»£ä»·çŸ©é˜µçš„æœ€ä¼˜åˆ†é…ä»ç„¶æ˜¯åŸä»£ä»·çŸ©é˜µçš„æœ€ä¼˜åˆ†é…ã€‚

| ç®—æ³•æ­¥éª¤ |                                                              |
| -------- | ------------------------------------------------------------ |
| 1.       | å¯¹äºçŸ©é˜µçš„æ¯ä¸€è¡Œï¼Œå‡å»å…¶ä¸­æœ€å°çš„å…ƒç´                          |
| 2.       | å¯¹äºçŸ©é˜µçš„æ¯ä¸€åˆ—ï¼Œå‡å»å…¶ä¸­æœ€å°çš„å…ƒç´                          |
| 3.       | ç”¨æœ€å°‘çš„æ°´å¹³çº¿æˆ–å‚ç›´çº¿è¦†ç›–çŸ©é˜µä¸­æ‰€æœ‰çš„0                      |
| 4.       | å¦‚æœçº¿çš„æ•°é‡ç­‰äºNï¼Œåˆ™æ‰¾åˆ°äº†æœ€ä¼˜åˆ†é…ï¼Œç®—æ³•ç»“æŸï¼Œå¦åˆ™è¿›å…¥æ­¥éª¤5 |
| 5.       | æ‰¾åˆ°æ²¡æœ‰è¢«ä»»ä½•çº¿è¦†ç›–çš„æœ€å°å…ƒç´ ï¼Œæ¯ä¸ªæ²¡è¢«çº¿è¦†ç›–çš„è¡Œå‡å»è¿™ä¸ªå…ƒç´ ï¼Œæ¯ä¸ªè¢«çº¿è¦†ç›–çš„åˆ—åŠ ä¸Šè¿™ä¸ªå…ƒç´ ï¼Œè¿”å›æ­¥éª¤3 |

ç»§ç»­æ‹¿ä¸Šé¢çš„ä¾‹å­åšæ¼”ç¤ºï¼š

step1 æ¯ä¸€è¡Œæœ€å°çš„å…ƒç´ åˆ†åˆ«ä¸º15ã€20ã€20ï¼Œå‡å»å¾—åˆ°ï¼š

|         | task1 | task2 | task3 |
| ------- | ----- | ----- | ----- |
| person1 | 0     | 25    | 30    |
| person2 | 0     | 40    | 15    |
| person3 | 0     | 20    | 5     |

step2 æ¯ä¸€åˆ—æœ€å°çš„å…ƒç´ åˆ†åˆ«ä¸º0ã€20ã€5ï¼Œå‡å»å¾—åˆ°ï¼š

|         | task1 | task2 | task3 |
| ------- | ----- | ----- | ----- |
| person1 | 0     | 5     | 25    |
| person2 | 0     | 20    | 10    |
| person3 | 0     | 0     | 0     |

step3 ç”¨æœ€å°‘çš„æ°´å¹³çº¿æˆ–å‚ç›´çº¿è¦†ç›–æ‰€æœ‰çš„0ï¼Œå¾—åˆ°ï¼š

|         | task1 | task2 | task3 |
| ------- | ----- | ----- | ----- |
| person1 | 0     | 5     | 25    |
| person2 | 0     | 20    | 10    |
| person3 | 0     | 0     | 0     |

step4ï¼šçº¿çš„æ•°é‡ä¸º3ï¼Œæ»¡è¶³æ¡ä»¶ï¼Œç®—æ³•ç»“æŸã€‚æ˜¾ç„¶ï¼Œå°†ä»»åŠ¡2åˆ†é…ç»™ç¬¬1ä¸ªäººã€ä»»åŠ¡1åˆ†é…ç»™ç¬¬2ä¸ªäººã€ä»»åŠ¡3åˆ†é…ç»™ç¬¬3ä¸ªäººæ—¶ï¼Œæ€»çš„ä»£ä»·æœ€å°ï¼ˆ0+0+0=0ï¼‰

|         | task1 | task2 | task3 |
| ------- | ----- | ----- | ----- |
| person1 | 0     | 5     | 20    |
| person2 | 0     | 15    | 5     |
| person3 | 0     | 0     | 0     |

æ‰€ä»¥åŸçŸ©é˜µçš„æœ€å°æ€»ä»£ä»·ä¸ºï¼ˆ40+20+25=85ï¼‰ï¼š

|         | task1 | task2 | task3 |
| ------- | ----- | ----- | ----- |
| person1 | 15    | 40    | 45    |
| person2 | 20    | 60    | 35    |
| person3 | 20    | 40    | 25    |

sklearné‡Œçš„linear_assignment()å‡½æ•°ä»¥åŠscipyé‡Œçš„linear_sum_assignment()å‡½æ•°éƒ½å®ç°äº†åŒˆç‰™åˆ©ç®—æ³•ï¼Œä¸¤è€…çš„è¿”å›å€¼çš„å½¢å¼ä¸åŒï¼š

```python
import numpy as np 
from sklearn.utils.linear_assignment_ import linear_assignment
from scipy.optimize import linear_sum_assignment
 
cost_matrix = np.array([
    [15,40,45],
    [20,60,35],
    [20,40,25]
])
 
matches = linear_assignment(cost_matrix)
print('sklearn API result:\n', matches)
matches = linear_sum_assignment(cost_matrix)
print('scipy API result:\n', matches)
 

"""Outputs
sklearn API result:
 [[0 1]
  [1 0]
  [2 2]]
scipy API result:
 (array([0, 1, 2], dtype=int64), array([1, 0, 2], dtype=int64))
"""
```

åœ¨DeepSORTä¸­ï¼ŒåŒˆç‰™åˆ©ç®—æ³•ç”¨æ¥å°†å‰ä¸€å¸§ä¸­çš„è·Ÿè¸ªæ¡†tracksä¸å½“å‰å¸§ä¸­çš„æ£€æµ‹æ¡†detectionsè¿›è¡Œå…³è”ï¼Œé€šè¿‡å¤–è§‚ä¿¡æ¯ï¼ˆappearance informationï¼‰å’Œé©¬æ°è·ç¦»ï¼ˆMahalanobis distanceï¼‰ï¼Œæˆ–è€…IOUæ¥è®¡ç®—ä»£ä»·çŸ©é˜µã€‚

```python
#  linear_assignment.py
def min_cost_matching(distance_metric, max_distance, tracks, detections, 
                      track_indices=None, detection_indices=None):
    ...
    
    # è®¡ç®—ä»£ä»·çŸ©é˜µ
    cost_matrix = distance_metric(tracks, detections, track_indices, detection_indices)
    cost_matrix[cost_matrix > max_distance] = max_distance + 1e-5
    
    # æ‰§è¡ŒåŒˆç‰™åˆ©ç®—æ³•ï¼Œå¾—åˆ°åŒ¹é…æˆåŠŸçš„ç´¢å¼•å¯¹ï¼Œè¡Œç´¢å¼•ä¸ºtracksçš„ç´¢å¼•ï¼Œåˆ—ç´¢å¼•ä¸ºdetectionsçš„ç´¢å¼•
    row_indices, col_indices = linear_assignment(cost_matrix)
 
    matches, unmatched_tracks, unmatched_detections = [], [], []
 
    # æ‰¾å‡ºæœªåŒ¹é…çš„detections
    for col, detection_idx in enumerate(detection_indices):
        if col not in col_indices:
            unmatched_detections.append(detection_idx)
     
    # æ‰¾å‡ºæœªåŒ¹é…çš„tracks
    for row, track_idx in enumerate(track_indices):
        if row not in row_indices:
            unmatched_tracks.append(track_idx)
    
    # éå†åŒ¹é…çš„(track, detection)ç´¢å¼•å¯¹
    for row, col in zip(row_indices, col_indices):
        track_idx = track_indices[row]
        detection_idx = detection_indices[col]
        # å¦‚æœç›¸åº”çš„costå¤§äºé˜ˆå€¼max_distanceï¼Œä¹Ÿè§†ä¸ºæœªåŒ¹é…æˆåŠŸ
        if cost_matrix[row, col] > max_distance:
            unmatched_tracks.append(track_idx)
            unmatched_detections.append(detection_idx)
        else:
            matches.append((track_idx, detection_idx))
 
    return matches, unmatched_tracks, unmatched_detections
```



##### deepsortåº”ç”¨

DeepSORTå¯¹æ¯ä¸€å¸§çš„å¤„ç†æµç¨‹å¦‚ä¸‹ï¼š

æ£€æµ‹å™¨å¾—åˆ°bbox â†’ ç”Ÿæˆdetections â†’ å¡å°”æ›¼æ»¤æ³¢é¢„æµ‹â†’ ä½¿ç”¨åŒˆç‰™åˆ©ç®—æ³•å°†é¢„æµ‹åçš„trackså’Œå½“å‰å¸§ä¸­çš„detecionsè¿›è¡ŒåŒ¹é…ï¼ˆçº§è”åŒ¹é…å’ŒIOUåŒ¹é…ï¼‰ â†’ å¡å°”æ›¼æ»¤æ³¢æ›´æ–°

> **Frame 0ï¼š**æ£€æµ‹å™¨æ£€æµ‹åˆ°äº†3ä¸ªdetectionsï¼Œå½“å‰æ²¡æœ‰ä»»ä½•tracksï¼Œå°†è¿™3ä¸ªdetectionsåˆå§‹åŒ–ä¸ºtracks
> **Frame 1ï¼š**æ£€æµ‹å™¨åˆæ£€æµ‹åˆ°äº†3ä¸ªdetectionsï¼Œå¯¹äºFrame 0ä¸­çš„tracksï¼Œå…ˆè¿›è¡Œé¢„æµ‹å¾—åˆ°æ–°çš„tracksï¼Œç„¶åä½¿ç”¨åŒˆç‰™åˆ©ç®—æ³•å°†æ–°çš„tracksä¸detectionsè¿›è¡ŒåŒ¹é…ï¼Œå¾—åˆ°(track, detection)åŒ¹é…å¯¹ï¼Œæœ€åç”¨æ¯å¯¹ä¸­çš„detectionæ›´æ–°å¯¹åº”çš„track

**æ£€æµ‹**

ä½¿ç”¨Yoloä½œä¸ºæ£€æµ‹å™¨ï¼Œæ£€æµ‹å½“å‰å¸§ä¸­çš„bboxï¼š

```python
#  demo_yolo3_deepsort.py
def detect(self):
    while self.vdo.grab():
	...
	bbox_xcycwh, cls_conf, cls_ids = self.yolo3(im)  # æ£€æµ‹åˆ°çš„bbox[cx,cy,w,h]ï¼Œç½®ä¿¡åº¦ï¼Œç±»åˆ«id
	if bbox_xcycwh is not None:
    	    # ç­›é€‰å‡ºäººçš„ç±»åˆ«
    	    mask = cls_ids == 0
  	    bbox_xcycwh = bbox_xcycwh[mask]
  	    bbox_xcycwh[:, 3:] *= 1.2
   	    cls_conf = cls_conf[mask]
            ...
```

**ç”Ÿæˆdetections**

å°†æ£€æµ‹åˆ°çš„bboxè½¬æ¢æˆdetectionsï¼š

```python
#  deep_sort.py
def update(self, bbox_xywh, confidences, ori_img):
    self.height, self.width = ori_img.shape[:2]
    # æå–æ¯ä¸ªbboxçš„feature
    features = self._get_features(bbox_xywh, ori_img)
    # [cx,cy,w,h] -> [x1,y1,w,h]
    bbox_tlwh = self._xywh_to_tlwh(bbox_xywh)
    # è¿‡æ»¤æ‰ç½®ä¿¡åº¦å°äºself.min_confidenceçš„bboxï¼Œç”Ÿæˆdetections
    detections = [Detection(bbox_tlwh[i], conf, features[i]) for i,conf in enumerate(confidences) if conf > self.min_confidence]
    # NMS (è¿™é‡Œself.nms_max_overlapçš„å€¼ä¸º1ï¼Œå³ä¿ç•™äº†æ‰€æœ‰çš„detections)
    boxes = np.array([d.tlwh for d in detections])
    scores = np.array([d.confidence for d in detections])
    indices = non_max_suppression(boxes, self.nms_max_overlap, scores)
    detections = [detections[i] for i in indices]
    ...
```

**å¡å°”æ›¼æ»¤æ³¢é¢„æµ‹é˜¶æ®µ**

ä½¿ç”¨å¡å°”æ›¼æ»¤æ³¢é¢„æµ‹å‰ä¸€å¸§ä¸­çš„tracksåœ¨å½“å‰å¸§çš„çŠ¶æ€ï¼š

```python
#  track.py
def predict(self, kf):
    """Propagate the state distribution to the current time step using a 
       Kalman filter prediction step.
    Parameters
    ----------
    kf: The Kalman filter.
    """
    self.mean, self.covariance = kf.predict(self.mean, self.covariance)  # é¢„æµ‹
    self.age += 1  # è¯¥trackè‡ªå‡ºç°ä»¥æ¥çš„æ€»å¸§æ•°åŠ 1
    self.time_since_update += 1  # è¯¥trackè‡ªæœ€è¿‘ä¸€æ¬¡æ›´æ–°ä»¥æ¥çš„æ€»å¸§æ•°åŠ 1
```

**åŒ¹é…**

é¦–å…ˆå¯¹åŸºäºå¤–è§‚ä¿¡æ¯çš„é©¬æ°è·ç¦»è®¡ç®—trackså’Œdetectionsçš„ä»£ä»·çŸ©é˜µï¼Œç„¶åç›¸ç»§è¿›è¡Œçº§è”åŒ¹é…å’ŒIOUåŒ¹é…ï¼Œæœ€åå¾—åˆ°å½“å‰å¸§çš„æ‰€æœ‰åŒ¹é…å¯¹ã€æœªåŒ¹é…çš„tracksä»¥åŠæœªåŒ¹é…çš„detectionsï¼š

```python
#  tracker.py
def _match(self, detections):
    def gated_metric(racks, dets, track_indices, detection_indices):
        """
        åŸºäºå¤–è§‚ä¿¡æ¯å’Œé©¬æ°è·ç¦»ï¼Œè®¡ç®—å¡å°”æ›¼æ»¤æ³¢é¢„æµ‹çš„trackså’Œå½“å‰æ—¶åˆ»æ£€æµ‹åˆ°çš„detectionsçš„ä»£ä»·çŸ©é˜µ
        """
        features = np.array([dets[i].feature for i in detection_indices])
        targets = np.array([tracks[i].track_id for i in track_indices]
	# åŸºäºå¤–è§‚ä¿¡æ¯ï¼Œè®¡ç®—trackså’Œdetectionsçš„ä½™å¼¦è·ç¦»ä»£ä»·çŸ©é˜µ
        cost_matrix = self.metric.distance(features, targets)
	# åŸºäºé©¬æ°è·ç¦»ï¼Œè¿‡æ»¤æ‰ä»£ä»·çŸ©é˜µä¸­ä¸€äº›ä¸åˆé€‚çš„é¡¹ (å°†å…¶è®¾ç½®ä¸ºä¸€ä¸ªè¾ƒå¤§çš„å€¼)
        cost_matrix = linear_assignment.gate_cost_matrix(self.kf, cost_matrix, tracks, 
                      dets, track_indices, detection_indices)
        return cost_matrix

    # åŒºåˆ†å¼€confirmed trackså’Œunconfirmed tracks
    confirmed_tracks = [i for i, t in enumerate(self.tracks) if t.is_confirmed()]
    unconfirmed_tracks = [i for i, t in enumerate(self.tracks) if not t.is_confirmed()]

    # å¯¹confirmd tracksè¿›è¡Œçº§è”åŒ¹é…
    matches_a, unmatched_tracks_a, unmatched_detections = \
        linear_assignment.matching_cascade(
            gated_metric, self.metric.matching_threshold, self.max_age,
            self.tracks, detections, confirmed_tracks)

    # å¯¹çº§è”åŒ¹é…ä¸­æœªåŒ¹é…çš„trackså’Œunconfirmed tracksä¸­time_since_updateä¸º1çš„tracksè¿›è¡ŒIOUåŒ¹é…
    iou_track_candidates = unconfirmed_tracks + [k for k in unmatched_tracks_a if
                                                 self.tracks[k].time_since_update == 1]
    unmatched_tracks_a = [k for k in unmatched_tracks_a if
                          self.tracks[k].time_since_update != 1]
    matches_b, unmatched_tracks_b, unmatched_detections = \
        linear_assignment.min_cost_matching(
            iou_matching.iou_cost, self.max_iou_distance, self.tracks,
            detections, iou_track_candidates, unmatched_detections)
	
    # æ•´åˆæ‰€æœ‰çš„åŒ¹é…å¯¹å’ŒæœªåŒ¹é…çš„tracks
    matches = matches_a + matches_b
    unmatched_tracks = list(set(unmatched_tracks_a + unmatched_tracks_b))
    
    return matches, unmatched_tracks, unmatched_detections


# çº§è”åŒ¹é…æºç   linear_assignment.py
def matching_cascade(distance_metric, max_distance, cascade_depth, tracks, detections, 
                     track_indices=None, detection_indices=None):
    ...
    unmatched_detections = detection_indice
    matches = []
    # ç”±å°åˆ°å¤§ä¾æ¬¡å¯¹æ¯ä¸ªlevelçš„tracksåšåŒ¹é…
    for level in range(cascade_depth):
	# å¦‚æœæ²¡æœ‰detectionsï¼Œé€€å‡ºå¾ªç¯
        if len(unmatched_detections) == 0:  
            break
	# å½“å‰levelçš„æ‰€æœ‰tracksç´¢å¼•
        track_indices_l = [k for k in track_indices if 
                           tracks[k].time_since_update == 1 + level]
	# å¦‚æœå½“å‰levelæ²¡æœ‰trackï¼Œç»§ç»­
        if len(track_indices_l) == 0: 
            continue
		
	# åŒˆç‰™åˆ©åŒ¹é…
        matches_l, _, unmatched_detections = min_cost_matching(distance_metric, max_distance, tracks, detections, 
                                                               track_indices_l, unmatched_detections)
        
	matches += matches_l
	unmatched_tracks = list(set(track_indices) - set(k for k, _ in matches))
    return matches, unmatched_tracks, unmatched_detections
```

**å¡å°”æ›¼æ»¤æ³¢æ›´æ–°é˜¶æ®µ**

å¯¹äºæ¯ä¸ªåŒ¹é…æˆåŠŸçš„trackï¼Œç”¨å…¶å¯¹åº”çš„detectionè¿›è¡Œæ›´æ–°ï¼Œå¹¶å¤„ç†æœªåŒ¹é…trackså’Œdetectionsï¼š

```python
#  tracker.py
def update(self, detections):
    """Perform measurement update and track management.
    Parameters
    ----------
    detections: List[deep_sort.detection.Detection]
                A list of detections at the current time step.
    """
    # å¾—åˆ°åŒ¹é…å¯¹ã€æœªåŒ¹é…çš„tracksã€æœªåŒ¹é…çš„dectections
    matches, unmatched_tracks, unmatched_detections = self._match(detections)

    # å¯¹äºæ¯ä¸ªåŒ¹é…æˆåŠŸçš„trackï¼Œç”¨å…¶å¯¹åº”çš„detectionè¿›è¡Œæ›´æ–°
    for track_idx, detection_idx in matches:
        self.tracks[track_idx].update(self.kf, detections[detection_idx])
    
	# å¯¹äºæœªåŒ¹é…çš„æˆåŠŸçš„trackï¼Œå°†å…¶æ ‡è®°ä¸ºä¸¢å¤±
	for track_idx in unmatched_tracks:
        self.tracks[track_idx].mark_missed()
	
    # å¯¹äºæœªåŒ¹é…æˆåŠŸçš„detectionï¼Œåˆå§‹åŒ–ä¸ºæ–°çš„track
    for detection_idx in unmatched_detections:
        self._initiate_track(detections[detection_idx])
    
	...
```